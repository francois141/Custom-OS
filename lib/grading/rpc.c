/*
 * Copyright (c) 2019, ETH Zurich.
 * Copyright (c) 2022, The University of British Columbia.
 * All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, Universitaetstrasse 6, CH-8092 Zurich. Attn: Systems Group.
 */

///////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                               //
//                   !! WARNING !!   DO NOT EDIT THIS FILE   !! WARNING !!                       //
//                                                                                               //
//      This file is part of the grading library and will be overwritten before grading.         //
//              To ensure tests are run correctly, do not edit this file                         //
//                                                                                               //
///////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdarg.h>
#include <stdio.h>

#include <aos/aos.h>
#include <aos/sys_debug.h>
#include <grading/grading.h>
#include <grading/state.h>
#include <grading/io.h>

void grading_rpc_handle_number(uintptr_t val)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: Number %" PRIuPTR " 0x%lx\n", val, val);
    }
}

void grading_rpc_handler_string(const char *string)
{
    if (grading_options.rpc_stub_enable) {
        size_t        len = strlen(string);
        unsigned char c   = 0;
        for (size_t i = 0; i < len; i++) {
            c = (c * 10) ^ string[i];
        }
        grading_printf("rpc-recv: string %zu %d '%s' \n", len, c, string);
    }
}

void grading_rpc_handler_serial_getchar(void)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: serial getchar\n");
    }
}

void grading_rpc_handler_serial_putchar(char c)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: serial putchar %c\n", c);
    }
}

void grading_rpc_handler_ram_cap(size_t bytes, size_t alignment)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: ram alloc bytes=%lu alignment=%lu\n", bytes, alignment);
    }
}

void grading_rpc_handler_process_spawn(char *cmdline, coreid_t core)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: process spawn cmdline=%s core=%lu\n", cmdline, core);
    }
}

void grading_rpc_handler_process_resume(domainid_t pid)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: process resume pid=%d\n", pid);
    }
}
void grading_rpc_handler_process_pause(domainid_t pid)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: process pause pid=%d\n", pid);
    }
}
void grading_rpc_handler_process_exit(domainid_t pid, int status)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: process exit pid=%d status=%d\n", pid, status);
    }
}
void grading_rpc_handler_process_wait(domainid_t pid)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: process wait pid=%d\n", pid);
    }
}
void grading_rpc_handler_process_kill(domainid_t pid)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: process kill pid=%d\n", pid);
    }
}
void grading_rpc_handler_process_killall(const char *name)
{
    if (grading_options.rpc_stub_enable) {
        grading_printf("rpc-recv: process killall %s\n", name);
    }
}